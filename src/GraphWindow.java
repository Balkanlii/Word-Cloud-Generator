import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;

import java.io.File;
import java.io.FileOutputStream;
import java.io.ObjectOutputStream;

import java.util.ArrayList;

import javax.swing.*;

import edu.uci.ics.jung.algorithms.layout.FRLayout;
import edu.uci.ics.jung.algorithms.layout.Layout;
import edu.uci.ics.jung.graph.DirectedSparseGraph;
import edu.uci.ics.jung.graph.Graph;
import edu.uci.ics.jung.graph.util.EdgeType;
import edu.uci.ics.jung.visualization.VisualizationViewer;
import edu.uci.ics.jung.visualization.control.DefaultModalGraphMouse;
import edu.uci.ics.jung.visualization.control.ModalGraphMouse;
import edu.uci.ics.jung.visualization.decorators.ToStringLabeller;
import edu.uci.ics.jung.visualization.picking.PickedState;


/**
 * GraphWindow
 * @author MasonSilber
 * This class is the class that displays the generated word cloud
 */
public class GraphWindow extends JFrame
{

	private static final long serialVersionUID = 1L;
	private static final int FRAME_WIDTH = 650;
	private static final int FRAME_HEIGHT = 650;

	private VisualizationViewer<String, Integer> vv;
	private DefaultModalGraphMouse<Integer, String> gm;
	private PickedState<String> pickedState;
	
	private ArrayList<String> URLs;
	private Graph<String,Integer> graph;
	private ArrayList<Node> nodes;
	private ArrayList<String> words;
	
	private JPanel panel;
	private JButton saveButton;
	private JButton searchButton;
	private JTextField searchTextField;
	
	ButtonGroup radioButtons;
	private JRadioButton pickerButton;
	private JRadioButton transformButton;
	

	
	/**
	 * GraphWindow constructor
	 * @param sites the list of URLs that will generate the word cloud
	 * This constructor is for a new word cloud
	 */
	public GraphWindow(ArrayList<String> sites, int numberOfAdj)
	{
		super("My Word Cloud");

		URLs = sites;
		graph = new DirectedSparseGraph<String,Integer>();
		nodes = HTMLParser.getWords(URLs, numberOfAdj);
		
		createDataGraph(nodes);
		createComponents();
		createPanel();

		setSize(FRAME_WIDTH,FRAME_HEIGHT);
	}

	/**
	 * GraphWindow constructor
	 * @param loadGraph List of nodes from which to create graph
	 * @param loadURLs List of URLs from which to create graph
	 * @param name Name of the window (based on the name of the serialized file
	 * This is the constructor for a serialized graph that's been loaded into the program
	 */
	public GraphWindow(ArrayList<Node> loadGraph, ArrayList<String> loadURLs,String name)
	{
		super(name);

		nodes = loadGraph;
		URLs = loadURLs;
		graph = new DirectedSparseGraph<String,Integer>();

		createDataGraph(nodes);
		createComponents();
		createRadioButtons();
		createPanel();

		setSize(FRAME_WIDTH,FRAME_HEIGHT);
	}

	/**
	 * createDataGraph
	 * @param nodes The nodes from which to create the graph
	 * This method creates the graph from the list of nodes generated by the HTML parser
	 * The total time complexity (detailed below) is O(V^2*E)
	 */
	public void createDataGraph(ArrayList<Node> nodes)
	{		
		//Add URL nodes
		//O(V)
		words = new ArrayList<String>();
		for(String URL : URLs)
		{
			graph.addVertex(URL);
		}

		//Add word nodes and connect them to their respective URLs
		//O(V*E)
		int i = 0;
		for(Node n : nodes)
		{
			graph.addVertex(n.getData());	

			for(String URL : n.getURLs())
			{
				n.addEdge(i);
				graph.addEdge(i++,URL,n.getData(),EdgeType.DIRECTED);
			}
		}

		//Connect words to their adjacent words (assuming they exist in the graph)
		//O(V^2*E) (ArrayList.contains() within two for loops)
		for(Node n : nodes)
		{	
			for(String adj : n.getFollowingAdjacencies())
			{
				if(graph.getVertices().contains(adj))
				{
					graph.addEdge(i++,n.getData(),adj,EdgeType.DIRECTED);
				}
			}
		}

		//Keep track of all the words in the graph (in order to be able to use ArrayList.contains() later)
		//O(V)
		for(Node n : nodes)
		{
			words.add(n.getData());
		}
		createJUNGGraph();
	}

	@SuppressWarnings({ "rawtypes", "unchecked" })
	/**
	 * createJUNGGraph
	 * This method uses the JUNG library to create the panel in which the graph is displayed
	 */
	public void createJUNGGraph()
	{
		Layout<String, Integer> layout = new FRLayout(graph);
		layout.setSize(new Dimension(600, 600));
		vv = new VisualizationViewer<String, Integer>(layout);
		vv.setPreferredSize(layout.getSize());
		// Show vertex and edge labels
		vv.getRenderContext().setVertexLabelTransformer(new ToStringLabeller());

		// Create a graph mouse and add it to the visualization component
		gm = new DefaultModalGraphMouse<Integer, String>();
		gm.setMode(ModalGraphMouse.Mode.TRANSFORMING);
		vv.setGraphMouse(gm);
		getContentPane().setLayout(new BorderLayout());
		getContentPane().add(vv,BorderLayout.CENTER);

		pickedState = vv.getPickedVertexState();
		
		pickedState.addItemListener(new ItemListener()
		{

			@Override
			public void itemStateChanged(ItemEvent e) {
				String node = (String) e.getItem();
				if(node instanceof String)
				{
					if(pickedState.isPicked(node))
					{
						if(node.indexOf(".") > 0)
						{
							pickedState.pick(node, false);
						}
						else
						{
							createClickedNodeWindow(node);
						}
					}
				}
			}
			
		});
		setSize(FRAME_WIDTH,FRAME_HEIGHT);
	}

	/**
	 * createClickedNodeWindow
	 * @param node The node that was clicked
	 * This creates the window for when the user clicks a node
	 */
	public void createClickedNodeWindow(String node)
	{
		Node selected = null;
		
		for(Node n:nodes)
		{
			if(n.equals(new Node(node)))
			{
				selected = n;
			}
		}
		
		if(selected != null)
		{
			NodeDetailWindow clicked = new NodeDetailWindow
			(selected.getFrequency(),
			selected.getURLs(),
			selected.getPreviousAdjacencies(),
			selected.getFollowingAdjacencies());
			
			clicked.setDefaultCloseOperation(HIDE_ON_CLOSE);
			clicked.pack();
			clicked.setVisible(true);
		}
		else
		{
			return;
		}
	}
	
	/**
	 * createComponents
	 * This method initializes and creates the components that will be added to the window (aside from the graph itself)
	 */
	public void createComponents()
	{		
		//Save Button
		createSaveButton();

		//Search Text Field
		searchTextField = new JTextField("Enter search term here",20);

		//Search button
		createSearchButton();
	}
	
	/**
	 * createSaveButton
	 * This method creates the save button and adds its functionality
	 */
	public void createSaveButton()
	{
		saveButton = new JButton("Save Cloud");
		
		/**
		 * SaveActionListener
		 * @author MasonSilber
		 * This is the action listener that brings up the save file
		 * dialog and allows the user to serialize the word cloud they've created
		 */
		class SaveActionListener implements ActionListener
		{
			/**
			 * actionPerformed
			 * This is the method that gets called when the save button is pressed. It brings up a 
			 * JFileChooser and allows the user to save the word cloud they've created through serialization
			 */
			public void actionPerformed(ActionEvent event)
			{
				JFileChooser fileChooser = new JFileChooser();
				int retVal = fileChooser.showSaveDialog(GraphWindow.this);

				if(retVal == JFileChooser.APPROVE_OPTION)
				{
					File savedFile = fileChooser.getSelectedFile();

					try 
					{
						ObjectOutputStream outStream = new ObjectOutputStream(new FileOutputStream(savedFile));

						outStream.writeObject(URLs);
						outStream.writeObject(nodes);
						outStream.close();
					}

					catch (Exception e) 
					{
						e.printStackTrace();
					}
				}
				else
				{
					return;
				}
			}
		};
		saveButton.addActionListener(new SaveActionListener());
	}
	
	/**
	 * createSearchButton
	 * This method creates the search button that the user can use to search the word cloud
	 */
	public void createSearchButton()
	{
		searchButton = new JButton("Search");
		
		/**
		 * SearchActionListener
		 * @author MasonSilber
		 * This is the action listener that performs the search function
		 */
		class SearchActionListener implements ActionListener
		{
			/**
			 * actionPerformed
			 * This is the method that gets called when the search button is pressed
			 * It will search the word cloud for a node with the given search term
			 */
			public void actionPerformed(ActionEvent event)
			{
				search();
			}
		}
		searchButton.addActionListener(new SearchActionListener());
	}
	
	/**
	 * search
	 * This method performs the search on the graph based on the user's search term
	 * O(V)
	 */
	public void search()
	{
		Node match = null;
		
		//Find matches
		//O(V) (linear search)
		for(Node n:nodes)
		{
			if(n.getData().equals(searchTextField.getText()))
			{
				match = n;
			}
		}

		//If there are search results
		//O(V) (for the adjacent URLS and the adjacent nodes on the creation of the results window)
		if(match != null)
		{
			NodeDetailWindow results = new NodeDetailWindow
			(match.getFrequency(),
			match.getURLs(),
			match.getPreviousAdjacencies(),
			match.getFollowingAdjacencies());
			
			results.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
			//results.pack();
			results.setVisible(true);
		}
		//If there aren't search results
		else
		{
			NoResultsWindow results = new NoResultsWindow();
			results.setDefaultCloseOperation(DO_NOTHING_ON_CLOSE);
			results.pack();
			results.setVisible(true);
		}			
	}

	/**
	 * createPanel
	 * This adds the search button and save button to the window
	 */
	public void createPanel()
	{
		createRadioButtons();
		

		
		JPanel topPanel = new JPanel();
		topPanel.setLayout(new BorderLayout());
		topPanel.add(transformButton,BorderLayout.EAST);
		topPanel.add(pickerButton,BorderLayout.CENTER);
		
		JPanel bottomPanel = new JPanel();
		bottomPanel.setLayout(new BorderLayout());
		bottomPanel.add(searchTextField,BorderLayout.CENTER);
		bottomPanel.add(searchButton,BorderLayout.EAST);
		bottomPanel.add(saveButton,BorderLayout.WEST);

		panel = new JPanel();
		panel.setLayout(new BorderLayout());
		panel.add(bottomPanel,BorderLayout.NORTH);
		panel.add(topPanel,BorderLayout.CENTER);
		getContentPane().add(panel,BorderLayout.NORTH);
	}

	/**
	 * getGraph
	 * @return the graph
	 */
	public Graph<String,Integer> getGraph()
	{
		return graph;
	}
	
	public void createRadioButtons()
	{
		radioButtons = new ButtonGroup();
		pickerButton = new JRadioButton("Picker Mode");
		transformButton = new JRadioButton("Transform Mode");
		
		radioButtons.add(pickerButton);
		radioButtons.add(transformButton);
		
		class PickerActionListener implements ActionListener
		{
			@Override
			public void actionPerformed(ActionEvent arg0) 
			{
				gm.setMode(ModalGraphMouse.Mode.PICKING);			
			}
		}
		
		class TransformActionListener implements ActionListener
		{
			@Override
			public void actionPerformed(ActionEvent e) 
			{
				gm.setMode(ModalGraphMouse.Mode.TRANSFORMING);
				if(pickedState.getPicked().size() > 0)
				{
					for(String s : pickedState.getPicked())
					{
						pickedState.pick(s, false);
					}
				}
			}	
		}
		
		pickerButton.addActionListener(new PickerActionListener());
		transformButton.addActionListener(new TransformActionListener());
		transformButton.setSelected(true);
	}
}
